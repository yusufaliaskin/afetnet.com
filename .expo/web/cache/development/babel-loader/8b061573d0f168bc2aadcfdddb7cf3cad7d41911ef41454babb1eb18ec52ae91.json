{"ast":null,"code":"\"use strict\";\n\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nimport { BaseGesture, Gesture } from \"./gesture\";\nfunction extendRelation(currentRelation, extendWith) {\n  if (currentRelation === undefined) {\n    return _toConsumableArray(extendWith);\n  } else {\n    return [].concat(_toConsumableArray(currentRelation), _toConsumableArray(extendWith));\n  }\n}\nexport var ComposedGesture = function (_Gesture) {\n  function ComposedGesture() {\n    var _this;\n    _classCallCheck(this, ComposedGesture);\n    _this = _callSuper(this, ComposedGesture);\n    _this.gestures = [];\n    _this.simultaneousGestures = [];\n    _this.requireGesturesToFail = [];\n    for (var _len = arguments.length, gestures = new Array(_len), _key = 0; _key < _len; _key++) {\n      gestures[_key] = arguments[_key];\n    }\n    _this.gestures = gestures;\n    return _this;\n  }\n  _inherits(ComposedGesture, _Gesture);\n  return _createClass(ComposedGesture, [{\n    key: \"prepareSingleGesture\",\n    value: function prepareSingleGesture(gesture, simultaneousGestures, requireGesturesToFail) {\n      if (gesture instanceof BaseGesture) {\n        var newConfig = _objectSpread({}, gesture.config);\n        newConfig.simultaneousWith = extendRelation(newConfig.simultaneousWith, simultaneousGestures);\n        newConfig.requireToFail = extendRelation(newConfig.requireToFail, requireGesturesToFail);\n        gesture.config = newConfig;\n      } else if (gesture instanceof ComposedGesture) {\n        gesture.simultaneousGestures = simultaneousGestures;\n        gesture.requireGesturesToFail = requireGesturesToFail;\n        gesture.prepare();\n      }\n    }\n  }, {\n    key: \"prepare\",\n    value: function prepare() {\n      for (var gesture of this.gestures) {\n        this.prepareSingleGesture(gesture, this.simultaneousGestures, this.requireGesturesToFail);\n      }\n    }\n  }, {\n    key: \"initialize\",\n    value: function initialize() {\n      for (var gesture of this.gestures) {\n        gesture.initialize();\n      }\n    }\n  }, {\n    key: \"toGestureArray\",\n    value: function toGestureArray() {\n      return this.gestures.flatMap(function (gesture) {\n        return gesture.toGestureArray();\n      });\n    }\n  }]);\n}(Gesture);\nexport var SimultaneousGesture = function (_ComposedGesture2) {\n  function SimultaneousGesture() {\n    _classCallCheck(this, SimultaneousGesture);\n    return _callSuper(this, SimultaneousGesture, arguments);\n  }\n  _inherits(SimultaneousGesture, _ComposedGesture2);\n  return _createClass(SimultaneousGesture, [{\n    key: \"prepare\",\n    value: function prepare() {\n      var _this2 = this;\n      var simultaneousArrays = this.gestures.map(function (gesture) {\n        return (_this2.gestures.filter(function (x) {\n            return x !== gesture;\n          }).flatMap(function (x) {\n            return x.toGestureArray();\n          })\n        );\n      });\n      for (var i = 0; i < this.gestures.length; i++) {\n        this.prepareSingleGesture(this.gestures[i], simultaneousArrays[i], this.requireGesturesToFail);\n      }\n    }\n  }]);\n}(ComposedGesture);\nexport var ExclusiveGesture = function (_ComposedGesture3) {\n  function ExclusiveGesture() {\n    _classCallCheck(this, ExclusiveGesture);\n    return _callSuper(this, ExclusiveGesture, arguments);\n  }\n  _inherits(ExclusiveGesture, _ComposedGesture3);\n  return _createClass(ExclusiveGesture, [{\n    key: \"prepare\",\n    value: function prepare() {\n      var gestureArrays = this.gestures.map(function (gesture) {\n        return gesture.toGestureArray();\n      });\n      var requireToFail = [];\n      for (var i = 0; i < this.gestures.length; i++) {\n        this.prepareSingleGesture(this.gestures[i], this.simultaneousGestures, this.requireGesturesToFail.concat(requireToFail));\n        requireToFail = requireToFail.concat(gestureArrays[i]);\n      }\n    }\n  }]);\n}(ComposedGesture);","map":{"version":3,"names":["BaseGesture","Gesture","extendRelation","currentRelation","extendWith","undefined","_toConsumableArray","concat","ComposedGesture","_Gesture","_this","_classCallCheck","_callSuper","gestures","simultaneousGestures","requireGesturesToFail","_len","arguments","length","Array","_key","_inherits","_createClass","key","value","prepareSingleGesture","gesture","newConfig","_objectSpread","config","simultaneousWith","requireToFail","prepare","initialize","toGestureArray","flatMap","SimultaneousGesture","_ComposedGesture2","_this2","simultaneousArrays","map","filter","x","i","ExclusiveGesture","_ComposedGesture3","gestureArrays"],"sources":["C:\\Users\\Yusuf Ali Aşkın\\Downloads\\Desktop\\proje_afetnet\\node_modules\\react-native-gesture-handler\\src\\handlers\\gestures\\gestureComposition.ts"],"sourcesContent":["import { BaseGesture, Gesture, GestureRef, GestureType } from './gesture';\n\nfunction extendRelation(\n  currentRelation: GestureRef[] | undefined,\n  extendWith: GestureType[]\n) {\n  if (currentRelation === undefined) {\n    return [...extendWith];\n  } else {\n    return [...currentRelation, ...extendWith];\n  }\n}\n\nexport class ComposedGesture extends Gesture {\n  protected gestures: Gesture[] = [];\n  protected simultaneousGestures: GestureType[] = [];\n  protected requireGesturesToFail: GestureType[] = [];\n\n  constructor(...gestures: Gesture[]) {\n    super();\n    this.gestures = gestures;\n  }\n\n  protected prepareSingleGesture(\n    gesture: Gesture,\n    simultaneousGestures: GestureType[],\n    requireGesturesToFail: GestureType[]\n  ) {\n    if (gesture instanceof BaseGesture) {\n      const newConfig = { ...gesture.config };\n\n      // No need to extend `blocksHandlers` here, because it's not changed in composition.\n      // The same effect is achieved by reversing the order of 2 gestures in `Exclusive`\n      newConfig.simultaneousWith = extendRelation(\n        newConfig.simultaneousWith,\n        simultaneousGestures\n      );\n      newConfig.requireToFail = extendRelation(\n        newConfig.requireToFail,\n        requireGesturesToFail\n      );\n\n      gesture.config = newConfig;\n    } else if (gesture instanceof ComposedGesture) {\n      gesture.simultaneousGestures = simultaneousGestures;\n      gesture.requireGesturesToFail = requireGesturesToFail;\n      gesture.prepare();\n    }\n  }\n\n  prepare() {\n    for (const gesture of this.gestures) {\n      this.prepareSingleGesture(\n        gesture,\n        this.simultaneousGestures,\n        this.requireGesturesToFail\n      );\n    }\n  }\n\n  initialize() {\n    for (const gesture of this.gestures) {\n      gesture.initialize();\n    }\n  }\n\n  toGestureArray(): GestureType[] {\n    return this.gestures.flatMap((gesture) => gesture.toGestureArray());\n  }\n}\n\nexport class SimultaneousGesture extends ComposedGesture {\n  prepare() {\n    // This piece of magic works something like this:\n    // for every gesture in the array\n    const simultaneousArrays = this.gestures.map((gesture) =>\n      // we take the array it's in\n      this.gestures\n        // and make a copy without it\n        .filter((x) => x !== gesture)\n        // then we flatmap the result to get list of raw (not composed) gestures\n        // this way we don't make the gestures simultaneous with themselves, which is\n        // important when the gesture is `ExclusiveGesture` - we don't want to make\n        // exclusive gestures simultaneous\n        .flatMap((x) => x.toGestureArray())\n    );\n\n    for (let i = 0; i < this.gestures.length; i++) {\n      this.prepareSingleGesture(\n        this.gestures[i],\n        simultaneousArrays[i],\n        this.requireGesturesToFail\n      );\n    }\n  }\n}\n\nexport class ExclusiveGesture extends ComposedGesture {\n  prepare() {\n    // Transforms the array of gestures into array of grouped raw (not composed) gestures\n    // i.e. [gesture1, gesture2, ComposedGesture(gesture3, gesture4)] -> [[gesture1], [gesture2], [gesture3, gesture4]]\n    const gestureArrays = this.gestures.map((gesture) =>\n      gesture.toGestureArray()\n    );\n\n    let requireToFail: GestureType[] = [];\n\n    for (let i = 0; i < this.gestures.length; i++) {\n      this.prepareSingleGesture(\n        this.gestures[i],\n        this.simultaneousGestures,\n        this.requireGesturesToFail.concat(requireToFail)\n      );\n\n      // Every group gets to wait for all groups before it\n      requireToFail = requireToFail.concat(gestureArrays[i]);\n    }\n  }\n}\n\nexport type ComposedGestureType = InstanceType<typeof ComposedGesture>;\nexport type RaceGestureType = ComposedGestureType;\nexport type SimultaneousGestureType = InstanceType<typeof SimultaneousGesture>;\nexport type ExclusiveGestureType = InstanceType<typeof ExclusiveGesture>;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}