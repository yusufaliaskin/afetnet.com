{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nvar BlobPolyfill = function () {\n  function BlobPolyfill() {\n    var blobParts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    _classCallCheck(this, BlobPolyfill);\n    this.size = 0;\n    this.type = options.type || '';\n    this._parts = [];\n    if (blobParts) {\n      for (var part of blobParts) {\n        if (typeof part === 'string') {\n          this._parts.push(part);\n          this.size += part.length;\n        } else if (part instanceof ArrayBuffer) {\n          this._parts.push(part);\n          this.size += part.byteLength;\n        } else if (part && typeof part === 'object' && part.buffer) {\n          this._parts.push(part.buffer);\n          this.size += part.buffer.byteLength;\n        }\n      }\n    }\n  }\n  return _createClass(BlobPolyfill, [{\n    key: \"slice\",\n    value: function slice() {\n      var start = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.size;\n      var contentType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n      var slicedParts = [];\n      var currentPos = 0;\n      for (var part of this._parts) {\n        var partSize = typeof part === 'string' ? part.length : part.byteLength;\n        if (currentPos + partSize > start && currentPos < end) {\n          var sliceStart = Math.max(0, start - currentPos);\n          var sliceEnd = Math.min(partSize, end - currentPos);\n          if (typeof part === 'string') {\n            slicedParts.push(part.slice(sliceStart, sliceEnd));\n          } else {\n            slicedParts.push(part.slice(sliceStart, sliceEnd));\n          }\n        }\n        currentPos += partSize;\n      }\n      return new BlobPolyfill(slicedParts, {\n        type: contentType\n      });\n    }\n  }, {\n    key: \"text\",\n    value: function text() {\n      return Promise.resolve(this._parts.join(''));\n    }\n  }, {\n    key: \"arrayBuffer\",\n    value: function arrayBuffer() {\n      var buffer = new ArrayBuffer(this.size);\n      var view = new Uint8Array(buffer);\n      var offset = 0;\n      for (var part of this._parts) {\n        if (typeof part === 'string') {\n          var encoder = new TextEncoder();\n          var encoded = encoder.encode(part);\n          view.set(encoded, offset);\n          offset += encoded.length;\n        } else {\n          var partView = new Uint8Array(part);\n          view.set(partView, offset);\n          offset += partView.length;\n        }\n      }\n      return Promise.resolve(buffer);\n    }\n  }, {\n    key: \"stream\",\n    value: function stream() {\n      return {\n        getReader: function getReader() {\n          var index = 0;\n          var parts = this._parts;\n          return {\n            read: function read() {\n              if (index >= parts.length) {\n                return Promise.resolve({\n                  done: true\n                });\n              }\n              var part = parts[index++];\n              var value;\n              if (typeof part === 'string') {\n                var encoder = new TextEncoder();\n                value = encoder.encode(part);\n              } else {\n                value = new Uint8Array(part);\n              }\n              return Promise.resolve({\n                value: value,\n                done: false\n              });\n            }\n          };\n        }\n      };\n    }\n  }]);\n}();\nexport default BlobPolyfill;\nexport { BlobPolyfill as Blob };\nif (typeof module !== 'undefined' && module.exports) {\n  module.exports = BlobPolyfill;\n  module.exports.default = BlobPolyfill;\n  module.exports.Blob = BlobPolyfill;\n}\nif (typeof global !== 'undefined' && !global.Blob) {\n  global.Blob = BlobPolyfill;\n}","map":{"version":3,"names":["BlobPolyfill","blobParts","arguments","length","undefined","options","_classCallCheck","size","type","_parts","part","push","ArrayBuffer","byteLength","buffer","_createClass","key","value","slice","start","end","contentType","slicedParts","currentPos","partSize","sliceStart","Math","max","sliceEnd","min","text","Promise","resolve","join","arrayBuffer","view","Uint8Array","offset","encoder","TextEncoder","encoded","encode","set","partView","stream","getReader","index","parts","read","done","Blob","module","exports","default","global"],"sources":["C:/Users/Yusuf Ali Aşkın/Desktop/proje_afetnet/src/polyfills/Blob.js"],"sourcesContent":["// Blob polyfill for React Native\r\n\r\n// Create a basic Blob implementation for React Native\r\nclass BlobPolyfill {\r\n  constructor(blobParts = [], options = {}) {\r\n    this.size = 0;\r\n    this.type = options.type || '';\r\n    this._parts = [];\r\n    \r\n    if (blobParts) {\r\n      for (const part of blobParts) {\r\n        if (typeof part === 'string') {\r\n          this._parts.push(part);\r\n          this.size += part.length;\r\n        } else if (part instanceof ArrayBuffer) {\r\n          this._parts.push(part);\r\n          this.size += part.byteLength;\r\n        } else if (part && typeof part === 'object' && part.buffer) {\r\n          this._parts.push(part.buffer);\r\n          this.size += part.buffer.byteLength;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  \r\n  slice(start = 0, end = this.size, contentType = '') {\r\n    const slicedParts = [];\r\n    let currentPos = 0;\r\n    \r\n    for (const part of this._parts) {\r\n      const partSize = typeof part === 'string' ? part.length : part.byteLength;\r\n      \r\n      if (currentPos + partSize > start && currentPos < end) {\r\n        const sliceStart = Math.max(0, start - currentPos);\r\n        const sliceEnd = Math.min(partSize, end - currentPos);\r\n        \r\n        if (typeof part === 'string') {\r\n          slicedParts.push(part.slice(sliceStart, sliceEnd));\r\n        } else {\r\n          slicedParts.push(part.slice(sliceStart, sliceEnd));\r\n        }\r\n      }\r\n      \r\n      currentPos += partSize;\r\n    }\r\n    \r\n    return new BlobPolyfill(slicedParts, { type: contentType });\r\n  }\r\n  \r\n  text() {\r\n    return Promise.resolve(this._parts.join(''));\r\n  }\r\n  \r\n  arrayBuffer() {\r\n    const buffer = new ArrayBuffer(this.size);\r\n    const view = new Uint8Array(buffer);\r\n    let offset = 0;\r\n    \r\n    for (const part of this._parts) {\r\n      if (typeof part === 'string') {\r\n        const encoder = new TextEncoder();\r\n        const encoded = encoder.encode(part);\r\n        view.set(encoded, offset);\r\n        offset += encoded.length;\r\n      } else {\r\n        const partView = new Uint8Array(part);\r\n        view.set(partView, offset);\r\n        offset += partView.length;\r\n      }\r\n    }\r\n    \r\n    return Promise.resolve(buffer);\r\n  }\r\n  \r\n  stream() {\r\n    // Basic stream implementation\r\n    return {\r\n      getReader() {\r\n        let index = 0;\r\n        const parts = this._parts;\r\n        \r\n        return {\r\n          read() {\r\n            if (index >= parts.length) {\r\n              return Promise.resolve({ done: true });\r\n            }\r\n            \r\n            const part = parts[index++];\r\n            let value;\r\n            \r\n            if (typeof part === 'string') {\r\n              const encoder = new TextEncoder();\r\n              value = encoder.encode(part);\r\n            } else {\r\n              value = new Uint8Array(part);\r\n            }\r\n            \r\n            return Promise.resolve({ value, done: false });\r\n          }\r\n        };\r\n      }\r\n    };\r\n  }\r\n}\r\n\r\n// Export the Blob polyfill\r\nexport default BlobPolyfill;\r\nexport { BlobPolyfill as Blob };\r\n\r\n// CommonJS compatibility\r\nif (typeof module !== 'undefined' && module.exports) {\r\n  module.exports = BlobPolyfill;\r\n  module.exports.default = BlobPolyfill;\r\n  module.exports.Blob = BlobPolyfill;\r\n}\r\n\r\n// Global Blob if not available\r\nif (typeof global !== 'undefined' && !global.Blob) {\r\n  global.Blob = BlobPolyfill;\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}