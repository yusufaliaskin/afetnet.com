{"ast":null,"code":"\"use strict\";\n\nimport { useCallback } from 'react';\nimport { attachHandlers } from \"./attachHandlers\";\nimport { updateHandlers } from \"./updateHandlers\";\nimport { needsToReattach } from \"./needsToReattach\";\nimport { dropHandlers } from \"./dropHandlers\";\nimport { useForceRender, validateDetectorChildren } from \"./utils\";\nimport findNodeHandle from \"../../../findNodeHandle\";\nexport function useDetectorUpdater(state, preparedGesture, gesturesToAttach, gestureConfig, webEventHandlersRef) {\n  var forceRender = useForceRender();\n  var updateAttachedGestures = useCallback(function (skipConfigUpdate) {\n    var viewTag = findNodeHandle(state.viewRef);\n    var didUnderlyingViewChange = viewTag !== state.previousViewTag;\n    if (didUnderlyingViewChange || needsToReattach(preparedGesture, gesturesToAttach)) {\n      validateDetectorChildren(state.viewRef);\n      dropHandlers(preparedGesture);\n      attachHandlers({\n        preparedGesture: preparedGesture,\n        gestureConfig: gestureConfig,\n        gesturesToAttach: gesturesToAttach,\n        webEventHandlersRef: webEventHandlersRef,\n        viewTag: viewTag\n      });\n      if (didUnderlyingViewChange) {\n        state.previousViewTag = viewTag;\n        state.forceRebuildReanimatedEvent = true;\n        forceRender();\n      }\n    } else if (!skipConfigUpdate) {\n      updateHandlers(preparedGesture, gestureConfig, gesturesToAttach);\n    }\n  }, [forceRender, gestureConfig, gesturesToAttach, preparedGesture, state, webEventHandlersRef]);\n  return updateAttachedGestures;\n}","map":{"version":3,"names":["useCallback","attachHandlers","updateHandlers","needsToReattach","dropHandlers","useForceRender","validateDetectorChildren","findNodeHandle","useDetectorUpdater","state","preparedGesture","gesturesToAttach","gestureConfig","webEventHandlersRef","forceRender","updateAttachedGestures","skipConfigUpdate","viewTag","viewRef","didUnderlyingViewChange","previousViewTag","forceRebuildReanimatedEvent"],"sources":["C:\\Users\\Yusuf Ali Aşkın\\Downloads\\Desktop\\proje_afetnet\\node_modules\\react-native-gesture-handler\\src\\handlers\\gestures\\GestureDetector\\useDetectorUpdater.ts"],"sourcesContent":["import React, { useCallback } from 'react';\nimport { GestureType } from '../gesture';\nimport { ComposedGesture } from '../gestureComposition';\n\nimport {\n  AttachedGestureState,\n  GestureDetectorState,\n  WebEventHandler,\n} from './types';\nimport { attachHandlers } from './attachHandlers';\nimport { updateHandlers } from './updateHandlers';\nimport { needsToReattach } from './needsToReattach';\nimport { dropHandlers } from './dropHandlers';\nimport { useForceRender, validateDetectorChildren } from './utils';\nimport findNodeHandle from '../../../findNodeHandle';\n\n// Returns a function that's responsible for updating the attached gestures\n// If the view has changed, it will reattach the handlers to the new view\n// If the view remains the same, it will update the handlers with the new config\nexport function useDetectorUpdater(\n  state: GestureDetectorState,\n  preparedGesture: AttachedGestureState,\n  gesturesToAttach: GestureType[],\n  gestureConfig: ComposedGesture | GestureType,\n  webEventHandlersRef: React.RefObject<WebEventHandler>\n) {\n  const forceRender = useForceRender();\n  const updateAttachedGestures = useCallback(\n    // skipConfigUpdate is used to prevent unnecessary updates when only checking if the view has changed\n    (skipConfigUpdate?: boolean) => {\n      // If the underlying view has changed we need to reattach handlers to the new view\n      const viewTag = findNodeHandle(state.viewRef) as number;\n      const didUnderlyingViewChange = viewTag !== state.previousViewTag;\n\n      if (\n        didUnderlyingViewChange ||\n        needsToReattach(preparedGesture, gesturesToAttach)\n      ) {\n        validateDetectorChildren(state.viewRef);\n        dropHandlers(preparedGesture);\n        attachHandlers({\n          preparedGesture,\n          gestureConfig,\n          gesturesToAttach,\n          webEventHandlersRef,\n          viewTag,\n        });\n\n        if (didUnderlyingViewChange) {\n          state.previousViewTag = viewTag;\n          state.forceRebuildReanimatedEvent = true;\n          forceRender();\n        }\n      } else if (!skipConfigUpdate) {\n        updateHandlers(preparedGesture, gestureConfig, gesturesToAttach);\n      }\n    },\n    [\n      forceRender,\n      gestureConfig,\n      gesturesToAttach,\n      preparedGesture,\n      state,\n      webEventHandlersRef,\n    ]\n  );\n\n  return updateAttachedGestures;\n}\n"],"mappings":";;AAAA,SAAgBA,WAAW,QAAQ,OAAO;AAS1C,SAASC,cAAc;AACvB,SAASC,cAAc;AACvB,SAASC,eAAe;AACxB,SAASC,YAAY;AACrB,SAASC,cAAc,EAAEC,wBAAwB;AACjD,OAAOC,cAAc;AAKrB,OAAO,SAASC,kBAAkBA,CAChCC,KAA2B,EAC3BC,eAAqC,EACrCC,gBAA+B,EAC/BC,aAA4C,EAC5CC,mBAAqD,EACrD;EACA,IAAMC,WAAW,GAAGT,cAAc,CAAC,CAAC;EACpC,IAAMU,sBAAsB,GAAGf,WAAW,CAEvC,UAAAgB,gBAA0B,EAAK;IAE9B,IAAMC,OAAO,GAAGV,cAAc,CAACE,KAAK,CAACS,OAAO,CAAW;IACvD,IAAMC,uBAAuB,GAAGF,OAAO,KAAKR,KAAK,CAACW,eAAe;IAEjE,IACED,uBAAuB,IACvBhB,eAAe,CAACO,eAAe,EAAEC,gBAAgB,CAAC,EAClD;MACAL,wBAAwB,CAACG,KAAK,CAACS,OAAO,CAAC;MACvCd,YAAY,CAACM,eAAe,CAAC;MAC7BT,cAAc,CAAC;QACbS,eAAe,EAAfA,eAAe;QACfE,aAAa,EAAbA,aAAa;QACbD,gBAAgB,EAAhBA,gBAAgB;QAChBE,mBAAmB,EAAnBA,mBAAmB;QACnBI,OAAA,EAAAA;MACF,CAAC,CAAC;MAEF,IAAIE,uBAAuB,EAAE;QAC3BV,KAAK,CAACW,eAAe,GAAGH,OAAO;QAC/BR,KAAK,CAACY,2BAA2B,GAAG,IAAI;QACxCP,WAAW,CAAC,CAAC;MACf;IACF,CAAC,MAAM,IAAI,CAACE,gBAAgB,EAAE;MAC5Bd,cAAc,CAACQ,eAAe,EAAEE,aAAa,EAAED,gBAAgB,CAAC;IAClE;EACF,CAAC,EACD,CACEG,WAAW,EACXF,aAAa,EACbD,gBAAgB,EAChBD,eAAe,EACfD,KAAK,EACLI,mBAAmB,CAEvB,CAAC;EAED,OAAOE,sBAAsB;AAC/B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}