{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nvar BlobPolyfill = function () {\n  function BlobPolyfill() {\n    var parts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    _classCallCheck(this, BlobPolyfill);\n    this.parts = parts;\n    this.type = options.type || '';\n    this.size = this._calculateSize();\n  }\n  return _createClass(BlobPolyfill, [{\n    key: \"_calculateSize\",\n    value: function _calculateSize() {\n      return this.parts.reduce(function (total, part) {\n        if (typeof part === 'string') {\n          return total + new Blob([part]).size;\n        }\n        if (part instanceof ArrayBuffer) {\n          return total + part.byteLength;\n        }\n        if (part && typeof part.size === 'number') {\n          return total + part.size;\n        }\n        return total;\n      }, 0);\n    }\n  }, {\n    key: \"slice\",\n    value: function slice() {\n      var start = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.size;\n      var contentType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n      var slicedParts = [];\n      var currentPos = 0;\n      for (var part of this.parts) {\n        var partSize = typeof part === 'string' ? new Blob([part]).size : part instanceof ArrayBuffer ? part.byteLength : part.size || 0;\n        if (currentPos + partSize > start && currentPos < end) {\n          slicedParts.push(part);\n        }\n        currentPos += partSize;\n      }\n      return new BlobPolyfill(slicedParts, {\n        type: contentType\n      });\n    }\n  }, {\n    key: \"stream\",\n    value: function stream() {\n      return {\n        getReader: function getReader() {\n          var index = 0;\n          var parts = this.parts;\n          return {\n            read: function read() {\n              if (index >= parts.length) {\n                return Promise.resolve({\n                  done: true\n                });\n              }\n              var part = parts[index++];\n              var value = typeof part === 'string' ? new TextEncoder().encode(part) : new Uint8Array(part);\n              return Promise.resolve({\n                value: value,\n                done: false\n              });\n            }\n          };\n        }\n      };\n    }\n  }, {\n    key: \"text\",\n    value: function text() {\n      var _this = this;\n      return new Promise(function (resolve) {\n        var decoder = new TextDecoder();\n        var result = '';\n        for (var part of _this.parts) {\n          if (typeof part === 'string') {\n            result += part;\n          } else if (part instanceof ArrayBuffer) {\n            result += decoder.decode(part);\n          } else if (part instanceof Uint8Array) {\n            result += decoder.decode(part);\n          }\n        }\n        resolve(result);\n      });\n    }\n  }, {\n    key: \"arrayBuffer\",\n    value: function arrayBuffer() {\n      var _this2 = this;\n      return new Promise(function (resolve) {\n        var totalSize = _this2.size;\n        var buffer = new ArrayBuffer(totalSize);\n        var view = new Uint8Array(buffer);\n        var offset = 0;\n        for (var part of _this2.parts) {\n          if (typeof part === 'string') {\n            var encoded = new TextEncoder().encode(part);\n            view.set(encoded, offset);\n            offset += encoded.length;\n          } else if (part instanceof ArrayBuffer) {\n            view.set(new Uint8Array(part), offset);\n            offset += part.byteLength;\n          } else if (part instanceof Uint8Array) {\n            view.set(part, offset);\n            offset += part.length;\n          }\n        }\n        resolve(buffer);\n      });\n    }\n  }]);\n}();\nvar BlobImpl = typeof Blob !== 'undefined' ? Blob : BlobPolyfill;\nexport default BlobImpl;","map":{"version":3,"names":["BlobPolyfill","parts","arguments","length","undefined","options","_classCallCheck","type","size","_calculateSize","_createClass","key","value","reduce","total","part","Blob","ArrayBuffer","byteLength","slice","start","end","contentType","slicedParts","currentPos","partSize","push","stream","getReader","index","read","Promise","resolve","done","TextEncoder","encode","Uint8Array","text","_this","decoder","TextDecoder","result","decode","arrayBuffer","_this2","totalSize","buffer","view","offset","encoded","set","BlobImpl"],"sources":["C:/Users/Yusuf Ali Aşkın/Desktop/proje_afetnet/src/polyfills/Blob.js"],"sourcesContent":["// Blob polyfill for web\r\nclass BlobPolyfill {\r\n  constructor(parts = [], options = {}) {\r\n    this.parts = parts;\r\n    this.type = options.type || '';\r\n    this.size = this._calculateSize();\r\n  }\r\n\r\n  _calculateSize() {\r\n    return this.parts.reduce((total, part) => {\r\n      if (typeof part === 'string') {\r\n        return total + new Blob([part]).size;\r\n      }\r\n      if (part instanceof ArrayBuffer) {\r\n        return total + part.byteLength;\r\n      }\r\n      if (part && typeof part.size === 'number') {\r\n        return total + part.size;\r\n      }\r\n      return total;\r\n    }, 0);\r\n  }\r\n\r\n  slice(start = 0, end = this.size, contentType = '') {\r\n    const slicedParts = [];\r\n    let currentPos = 0;\r\n    \r\n    for (const part of this.parts) {\r\n      const partSize = typeof part === 'string' ? \r\n        new Blob([part]).size : \r\n        (part instanceof ArrayBuffer ? part.byteLength : (part.size || 0));\r\n      \r\n      if (currentPos + partSize > start && currentPos < end) {\r\n        slicedParts.push(part);\r\n      }\r\n      currentPos += partSize;\r\n    }\r\n    \r\n    return new BlobPolyfill(slicedParts, { type: contentType });\r\n  }\r\n\r\n  stream() {\r\n    // Basic stream implementation\r\n    return {\r\n      getReader() {\r\n        let index = 0;\r\n        const parts = this.parts;\r\n        \r\n        return {\r\n          read() {\r\n            if (index >= parts.length) {\r\n              return Promise.resolve({ done: true });\r\n            }\r\n            \r\n            const part = parts[index++];\r\n            const value = typeof part === 'string' ? \r\n              new TextEncoder().encode(part) : \r\n              new Uint8Array(part);\r\n            \r\n            return Promise.resolve({ value, done: false });\r\n          }\r\n        };\r\n      }\r\n    };\r\n  }\r\n\r\n  text() {\r\n    return new Promise((resolve) => {\r\n      const decoder = new TextDecoder();\r\n      let result = '';\r\n      \r\n      for (const part of this.parts) {\r\n        if (typeof part === 'string') {\r\n          result += part;\r\n        } else if (part instanceof ArrayBuffer) {\r\n          result += decoder.decode(part);\r\n        } else if (part instanceof Uint8Array) {\r\n          result += decoder.decode(part);\r\n        }\r\n      }\r\n      \r\n      resolve(result);\r\n    });\r\n  }\r\n\r\n  arrayBuffer() {\r\n    return new Promise((resolve) => {\r\n      const totalSize = this.size;\r\n      const buffer = new ArrayBuffer(totalSize);\r\n      const view = new Uint8Array(buffer);\r\n      let offset = 0;\r\n      \r\n      for (const part of this.parts) {\r\n        if (typeof part === 'string') {\r\n          const encoded = new TextEncoder().encode(part);\r\n          view.set(encoded, offset);\r\n          offset += encoded.length;\r\n        } else if (part instanceof ArrayBuffer) {\r\n          view.set(new Uint8Array(part), offset);\r\n          offset += part.byteLength;\r\n        } else if (part instanceof Uint8Array) {\r\n          view.set(part, offset);\r\n          offset += part.length;\r\n        }\r\n      }\r\n      \r\n      resolve(buffer);\r\n    });\r\n  }\r\n}\r\n\r\n// Use native Blob if available, otherwise use polyfill\r\nconst BlobImpl = typeof Blob !== 'undefined' ? Blob : BlobPolyfill;\r\n\r\nexport default BlobImpl;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}