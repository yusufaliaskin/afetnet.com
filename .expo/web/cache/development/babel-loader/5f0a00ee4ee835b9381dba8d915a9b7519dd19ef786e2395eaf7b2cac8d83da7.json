{"ast":null,"code":"\"use strict\";\n\nimport { registerHandler } from \"../../handlersRegistry\";\nimport RNGestureHandlerModule from \"../../../RNGestureHandlerModule\";\nimport { filterConfig, scheduleFlushOperations } from \"../../utils\";\nimport { ghQueueMicrotask } from \"../../../ghQueueMicrotask\";\nimport { extractGestureRelations, checkGestureCallbacksForWorklets, ALLOWED_PROPS } from \"./utils\";\nexport function updateHandlers(preparedGesture, gestureConfig, newGestures) {\n  gestureConfig.prepare();\n  for (var i = 0; i < newGestures.length; i++) {\n    var handler = preparedGesture.attachedGestures[i];\n    checkGestureCallbacksForWorklets(handler);\n    if (newGestures[i].handlerTag !== handler.handlerTag) {\n      newGestures[i].handlerTag = handler.handlerTag;\n      newGestures[i].handlers.handlerTag = handler.handlerTag;\n    }\n  }\n  var attachedGestures = preparedGesture.attachedGestures;\n  ghQueueMicrotask(function () {\n    if (!preparedGesture.isMounted) {\n      return;\n    }\n    if (attachedGestures !== preparedGesture.attachedGestures) {\n      return;\n    }\n    var shouldUpdateSharedValueIfUsed = attachedGestures.length !== newGestures.length;\n    for (var _i = 0; _i < newGestures.length; _i++) {\n      var _handler = attachedGestures[_i];\n      if (_handler.handlers.gestureId !== newGestures[_i].handlers.gestureId && (newGestures[_i].shouldUseReanimated || _handler.shouldUseReanimated)) {\n        shouldUpdateSharedValueIfUsed = true;\n      }\n      _handler.config = newGestures[_i].config;\n      _handler.handlers = newGestures[_i].handlers;\n      RNGestureHandlerModule.updateGestureHandler(_handler.handlerTag, filterConfig(_handler.config, ALLOWED_PROPS, extractGestureRelations(_handler)));\n      registerHandler(_handler.handlerTag, _handler, _handler.config.testId);\n    }\n    if (preparedGesture.animatedHandlers && shouldUpdateSharedValueIfUsed) {\n      var newHandlersValue = attachedGestures.filter(function (g) {\n        return g.shouldUseReanimated;\n      }).map(function (g) {\n        return g.handlers;\n      });\n      preparedGesture.animatedHandlers.value = newHandlersValue;\n    }\n    scheduleFlushOperations();\n  });\n}","map":{"version":3,"names":["registerHandler","RNGestureHandlerModule","filterConfig","scheduleFlushOperations","ghQueueMicrotask","extractGestureRelations","checkGestureCallbacksForWorklets","ALLOWED_PROPS","updateHandlers","preparedGesture","gestureConfig","newGestures","prepare","i","length","handler","attachedGestures","handlerTag","handlers","isMounted","shouldUpdateSharedValueIfUsed","gestureId","shouldUseReanimated","config","updateGestureHandler","testId","animatedHandlers","newHandlersValue","filter","g","map","value"],"sources":["C:\\Users\\Yusuf Ali Aşkın\\Downloads\\Desktop\\proje_afetnet\\node_modules\\react-native-gesture-handler\\src\\handlers\\gestures\\GestureDetector\\updateHandlers.ts"],"sourcesContent":["import { GestureType, HandlerCallbacks } from '../gesture';\nimport { registerHandler } from '../../handlersRegistry';\nimport RNGestureHandlerModule from '../../../RNGestureHandlerModule';\nimport { filterConfig, scheduleFlushOperations } from '../../utils';\nimport { ComposedGesture } from '../gestureComposition';\nimport { ghQueueMicrotask } from '../../../ghQueueMicrotask';\nimport { AttachedGestureState } from './types';\nimport {\n  extractGestureRelations,\n  checkGestureCallbacksForWorklets,\n  ALLOWED_PROPS,\n} from './utils';\n\nexport function updateHandlers(\n  preparedGesture: AttachedGestureState,\n  gestureConfig: ComposedGesture | GestureType,\n  newGestures: GestureType[]\n) {\n  gestureConfig.prepare();\n\n  for (let i = 0; i < newGestures.length; i++) {\n    const handler = preparedGesture.attachedGestures[i];\n    checkGestureCallbacksForWorklets(handler);\n\n    // Only update handlerTag when it's actually different, it may be the same\n    // if gesture config object is wrapped with useMemo\n    if (newGestures[i].handlerTag !== handler.handlerTag) {\n      newGestures[i].handlerTag = handler.handlerTag;\n      newGestures[i].handlers.handlerTag = handler.handlerTag;\n    }\n  }\n\n  // Store attached gestures to avoid crash when gestures changed after queueing micro task\n  const attachedGestures = preparedGesture.attachedGestures;\n\n  // Use queueMicrotask to extract handlerTags, because when it's ran, all refs should be updated\n  // and handlerTags in BaseGesture references should be updated in the loop above (we need to wait\n  // in case of external relations)\n  ghQueueMicrotask(() => {\n    if (!preparedGesture.isMounted) {\n      return;\n    }\n\n    // Stop if attached gestures changed after queueing micro task\n    if (attachedGestures !== preparedGesture.attachedGestures) {\n      return;\n    }\n\n    // If amount of gesture configs changes, we need to update the callbacks in shared value\n    let shouldUpdateSharedValueIfUsed =\n      attachedGestures.length !== newGestures.length;\n\n    for (let i = 0; i < newGestures.length; i++) {\n      const handler = attachedGestures[i];\n\n      // If the gestureId is different (gesture isn't wrapped with useMemo or its dependencies changed),\n      // we need to update the shared value, assuming the gesture runs on UI thread or the thread changed\n      if (\n        handler.handlers.gestureId !== newGestures[i].handlers.gestureId &&\n        (newGestures[i].shouldUseReanimated || handler.shouldUseReanimated)\n      ) {\n        shouldUpdateSharedValueIfUsed = true;\n      }\n\n      handler.config = newGestures[i].config;\n      handler.handlers = newGestures[i].handlers;\n\n      RNGestureHandlerModule.updateGestureHandler(\n        handler.handlerTag,\n        filterConfig(\n          handler.config,\n          ALLOWED_PROPS,\n          extractGestureRelations(handler)\n        )\n      );\n\n      registerHandler(handler.handlerTag, handler, handler.config.testId);\n    }\n\n    if (preparedGesture.animatedHandlers && shouldUpdateSharedValueIfUsed) {\n      const newHandlersValue = attachedGestures\n        .filter((g) => g.shouldUseReanimated) // Ignore gestures that shouldn't run on UI\n        .map((g) => g.handlers) as unknown as HandlerCallbacks<\n        Record<string, unknown>\n      >[];\n\n      preparedGesture.animatedHandlers.value = newHandlersValue;\n    }\n\n    scheduleFlushOperations();\n  });\n}\n"],"mappings":";;AACA,SAASA,eAAe;AACxB,OAAOC,sBAAsB;AAC7B,SAASC,YAAY,EAAEC,uBAAuB;AAE9C,SAASC,gBAAgB;AAEzB,SACEC,uBAAuB,EACvBC,gCAAgC,EAChCC,aAAa;AAGf,OAAO,SAASC,cAAcA,CAC5BC,eAAqC,EACrCC,aAA4C,EAC5CC,WAA0B,EAC1B;EACAD,aAAa,CAACE,OAAO,CAAC,CAAC;EAEvB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,WAAW,CAACG,MAAM,EAAED,CAAC,EAAE,EAAE;IAC3C,IAAME,OAAO,GAAGN,eAAe,CAACO,gBAAgB,CAACH,CAAC,CAAC;IACnDP,gCAAgC,CAACS,OAAO,CAAC;IAIzC,IAAIJ,WAAW,CAACE,CAAC,CAAC,CAACI,UAAU,KAAKF,OAAO,CAACE,UAAU,EAAE;MACpDN,WAAW,CAACE,CAAC,CAAC,CAACI,UAAU,GAAGF,OAAO,CAACE,UAAU;MAC9CN,WAAW,CAACE,CAAC,CAAC,CAACK,QAAQ,CAACD,UAAU,GAAGF,OAAO,CAACE,UAAU;IACzD;EACF;EAGA,IAAMD,gBAAgB,GAAGP,eAAe,CAACO,gBAAgB;EAKzDZ,gBAAgB,CAAC,YAAM;IACrB,IAAI,CAACK,eAAe,CAACU,SAAS,EAAE;MAC9B;IACF;IAGA,IAAIH,gBAAgB,KAAKP,eAAe,CAACO,gBAAgB,EAAE;MACzD;IACF;IAGA,IAAII,6BAA6B,GAC/BJ,gBAAgB,CAACF,MAAM,KAAKH,WAAW,CAACG,MAAM;IAEhD,KAAK,IAAID,EAAC,GAAG,CAAC,EAAEA,EAAC,GAAGF,WAAW,CAACG,MAAM,EAAED,EAAC,EAAE,EAAE;MAC3C,IAAME,QAAO,GAAGC,gBAAgB,CAACH,EAAC,CAAC;MAInC,IACEE,QAAO,CAACG,QAAQ,CAACG,SAAS,KAAKV,WAAW,CAACE,EAAC,CAAC,CAACK,QAAQ,CAACG,SAAS,KAC/DV,WAAW,CAACE,EAAC,CAAC,CAACS,mBAAmB,IAAIP,QAAO,CAACO,mBAAmB,CAAC,EACnE;QACAF,6BAA6B,GAAG,IAAI;MACtC;MAEAL,QAAO,CAACQ,MAAM,GAAGZ,WAAW,CAACE,EAAC,CAAC,CAACU,MAAM;MACtCR,QAAO,CAACG,QAAQ,GAAGP,WAAW,CAACE,EAAC,CAAC,CAACK,QAAQ;MAE1CjB,sBAAsB,CAACuB,oBAAoB,CACzCT,QAAO,CAACE,UAAU,EAClBf,YAAY,CACVa,QAAO,CAACQ,MAAM,EACdhB,aAAa,EACbF,uBAAuB,CAACU,QAAO,CACjC,CACF,CAAC;MAEDf,eAAe,CAACe,QAAO,CAACE,UAAU,EAAEF,QAAO,EAAEA,QAAO,CAACQ,MAAM,CAACE,MAAM,CAAC;IACrE;IAEA,IAAIhB,eAAe,CAACiB,gBAAgB,IAAIN,6BAA6B,EAAE;MACrE,IAAMO,gBAAgB,GAAGX,gBAAgB,CACtCY,MAAM,CAAE,UAAAC,CAAC;QAAA,OAAKA,CAAC,CAACP,mBAAmB;MAAA,EAAC,CACpCQ,GAAG,CAAE,UAAAD,CAAC;QAAA,OAAKA,CAAC,CAACX,QAAQ;MAAA,EAErB;MAEHT,eAAe,CAACiB,gBAAgB,CAACK,KAAK,GAAGJ,gBAAgB;IAC3D;IAEAxB,uBAAuB,CAAC,CAAC;EAC3B,CAAC,CAAC;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}