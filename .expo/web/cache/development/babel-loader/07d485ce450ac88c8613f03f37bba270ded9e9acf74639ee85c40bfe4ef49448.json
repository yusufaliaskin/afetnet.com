{"ast":null,"code":"\"use strict\";\nimport React, { useContext, useEffect, useLayoutEffect, useMemo, useRef } from 'react';\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport findNodeHandle from \"../../../findNodeHandle\";\nimport { isTestEnv } from \"../../../utils\";\nimport GestureHandlerRootViewContext from \"../../../GestureHandlerRootViewContext\";\nimport { useAnimatedGesture } from \"./useAnimatedGesture\";\nimport { attachHandlers } from \"./attachHandlers\";\nimport { needsToReattach } from \"./needsToReattach\";\nimport { dropHandlers } from \"./dropHandlers\";\nimport { useWebEventHandlers } from \"./utils\";\nimport { Wrap, AnimatedWrap } from \"./Wrap\";\nimport { useDetectorUpdater } from \"./useDetectorUpdater\";\nimport { useViewRefHandler } from \"./useViewRefHandler\";\nimport { useMountReactions } from \"./useMountReactions\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nfunction propagateDetectorConfig(props, gesture) {\n  var keysToPropagate = ['userSelect', 'enableContextMenu', 'touchAction'];\n  for (var key of keysToPropagate) {\n    var value = props[key];\n    if (value === undefined) {\n      continue;\n    }\n    for (var g of gesture.toGestureArray()) {\n      var config = g.config;\n      config[key] = value;\n    }\n  }\n}\nexport var GestureDetector = function GestureDetector(props) {\n  var rootViewContext = useContext(GestureHandlerRootViewContext);\n  if (__DEV__ && !rootViewContext && !isTestEnv() && Platform.OS !== 'web') {\n    throw new Error('GestureDetector must be used as a descendant of GestureHandlerRootView. Otherwise the gestures will not be recognized. See https://docs.swmansion.com/react-native-gesture-handler/docs/fundamentals/installation for more details.');\n  }\n  var gestureConfig = props.gesture;\n  propagateDetectorConfig(props, gestureConfig);\n  var gesturesToAttach = useMemo(function () {\n    return gestureConfig.toGestureArray();\n  }, [gestureConfig]);\n  var shouldUseReanimated = gesturesToAttach.some(function (g) {\n    return g.shouldUseReanimated;\n  });\n  var webEventHandlersRef = useWebEventHandlers();\n  var state = useRef({\n    firstRender: true,\n    viewRef: null,\n    previousViewTag: -1,\n    forceRebuildReanimatedEvent: false\n  }).current;\n  var preparedGesture = React.useRef({\n    attachedGestures: [],\n    animatedEventHandler: null,\n    animatedHandlers: null,\n    shouldUseReanimated: shouldUseReanimated,\n    isMounted: false\n  }).current;\n  var updateAttachedGestures = useDetectorUpdater(state, preparedGesture, gesturesToAttach, gestureConfig, webEventHandlersRef);\n  var refHandler = useViewRefHandler(state, updateAttachedGestures);\n  var needsToRebuildReanimatedEvent = state.firstRender || state.forceRebuildReanimatedEvent || needsToReattach(preparedGesture, gesturesToAttach);\n  state.forceRebuildReanimatedEvent = false;\n  useAnimatedGesture(preparedGesture, needsToRebuildReanimatedEvent);\n  useLayoutEffect(function () {\n    var viewTag = findNodeHandle(state.viewRef);\n    preparedGesture.isMounted = true;\n    attachHandlers({\n      preparedGesture: preparedGesture,\n      gestureConfig: gestureConfig,\n      gesturesToAttach: gesturesToAttach,\n      webEventHandlersRef: webEventHandlersRef,\n      viewTag: viewTag\n    });\n    return function () {\n      preparedGesture.isMounted = false;\n      dropHandlers(preparedGesture);\n    };\n  }, []);\n  useEffect(function () {\n    if (state.firstRender) {\n      state.firstRender = false;\n    } else {\n      updateAttachedGestures();\n    }\n  }, [props]);\n  useMountReactions(updateAttachedGestures, preparedGesture);\n  if (shouldUseReanimated) {\n    return _jsx(AnimatedWrap, {\n      ref: refHandler,\n      onGestureHandlerEvent: preparedGesture.animatedEventHandler,\n      children: props.children\n    });\n  } else {\n    return _jsx(Wrap, {\n      ref: refHandler,\n      children: props.children\n    });\n  }\n};","map":{"version":3,"names":["React","useContext","useEffect","useLayoutEffect","useMemo","useRef","Platform","findNodeHandle","isTestEnv","GestureHandlerRootViewContext","useAnimatedGesture","attachHandlers","needsToReattach","dropHandlers","useWebEventHandlers","Wrap","AnimatedWrap","useDetectorUpdater","useViewRefHandler","useMountReactions","jsx","_jsx","propagateDetectorConfig","props","gesture","keysToPropagate","key","value","undefined","g","toGestureArray","config","GestureDetector","rootViewContext","__DEV__","OS","Error","gestureConfig","gesturesToAttach","shouldUseReanimated","some","webEventHandlersRef","state","firstRender","viewRef","previousViewTag","forceRebuildReanimatedEvent","current","preparedGesture","attachedGestures","animatedEventHandler","animatedHandlers","isMounted","updateAttachedGestures","refHandler","needsToRebuildReanimatedEvent","viewTag","ref","onGestureHandlerEvent","children"],"sources":["C:\\Users\\Yusuf Ali Aşkın\\Downloads\\Desktop\\proje_afetnet\\node_modules\\react-native-gesture-handler\\src\\handlers\\gestures\\GestureDetector\\index.tsx"],"sourcesContent":["/* eslint-disable react/no-unused-prop-types */\nimport React, {\n  useContext,\n  useEffect,\n  useLayoutEffect,\n  useMemo,\n  useRef,\n} from 'react';\nimport { Platform } from 'react-native';\nimport findNodeHandle from '../../../findNodeHandle';\nimport { GestureType } from '../gesture';\nimport { UserSelect, TouchAction } from '../../gestureHandlerCommon';\nimport { ComposedGesture } from '../gestureComposition';\nimport { isTestEnv } from '../../../utils';\n\nimport GestureHandlerRootViewContext from '../../../GestureHandlerRootViewContext';\nimport { AttachedGestureState, GestureDetectorState } from './types';\nimport { useAnimatedGesture } from './useAnimatedGesture';\nimport { attachHandlers } from './attachHandlers';\nimport { needsToReattach } from './needsToReattach';\nimport { dropHandlers } from './dropHandlers';\nimport { useWebEventHandlers } from './utils';\nimport { Wrap, AnimatedWrap } from './Wrap';\nimport { useDetectorUpdater } from './useDetectorUpdater';\nimport { useViewRefHandler } from './useViewRefHandler';\nimport { useMountReactions } from './useMountReactions';\n\nfunction propagateDetectorConfig(\n  props: GestureDetectorProps,\n  gesture: ComposedGesture | GestureType\n) {\n  const keysToPropagate: (keyof GestureDetectorProps)[] = [\n    'userSelect',\n    'enableContextMenu',\n    'touchAction',\n  ];\n\n  for (const key of keysToPropagate) {\n    const value = props[key];\n    if (value === undefined) {\n      continue;\n    }\n\n    for (const g of gesture.toGestureArray()) {\n      const config = g.config as { [key: string]: unknown };\n      config[key] = value;\n    }\n  }\n}\n\ninterface GestureDetectorProps {\n  children?: React.ReactNode;\n  /**\n   * A gesture object containing the configuration and callbacks.\n   * Can be any of:\n   * - base gestures (`Tap`, `Pan`, ...)\n   * - `ComposedGesture` (`Race`, `Simultaneous`, `Exclusive`)\n   */\n  gesture: ComposedGesture | GestureType;\n  /**\n   * #### Web only\n   * This parameter allows to specify which `userSelect` property should be applied to underlying view.\n   * Possible values are `\"none\" | \"auto\" | \"text\"`. Default value is set to `\"none\"`.\n   */\n  userSelect?: UserSelect;\n  /**\n   * #### Web only\n   * Specifies whether context menu should be enabled after clicking on underlying view with right mouse button.\n   * Default value is set to `false`.\n   */\n  enableContextMenu?: boolean;\n  /**\n   * #### Web only\n   * This parameter allows to specify which `touchAction` property should be applied to underlying view.\n   * Supports all CSS touch-action values (e.g. `\"none\"`, `\"pan-y\"`). Default value is set to `\"none\"`.\n   */\n  touchAction?: TouchAction;\n}\n\n/**\n * `GestureDetector` is responsible for creating and updating native gesture handlers based on the config of provided gesture.\n *\n * ### Props\n * - `gesture`\n * - `userSelect` (**Web only**)\n * - `enableContextMenu` (**Web only**)\n * - `touchAction` (**Web only**)\n *\n * ### Remarks\n * - Gesture Detector will use first native view in its subtree to recognize gestures, however if this view is used only to group its children it may get automatically collapsed.\n * - Using the same instance of a gesture across multiple Gesture Detectors is not possible.\n *\n * @see https://docs.swmansion.com/react-native-gesture-handler/docs/gestures/gesture-detector\n */\nexport const GestureDetector = (props: GestureDetectorProps) => {\n  const rootViewContext = useContext(GestureHandlerRootViewContext);\n  if (__DEV__ && !rootViewContext && !isTestEnv() && Platform.OS !== 'web') {\n    throw new Error(\n      'GestureDetector must be used as a descendant of GestureHandlerRootView. Otherwise the gestures will not be recognized. See https://docs.swmansion.com/react-native-gesture-handler/docs/fundamentals/installation for more details.'\n    );\n  }\n\n  // Gesture config should be wrapped with useMemo to prevent unnecessary re-renders\n  const gestureConfig = props.gesture;\n  propagateDetectorConfig(props, gestureConfig);\n\n  const gesturesToAttach = useMemo(\n    () => gestureConfig.toGestureArray(),\n    [gestureConfig]\n  );\n  const shouldUseReanimated = gesturesToAttach.some(\n    (g) => g.shouldUseReanimated\n  );\n\n  const webEventHandlersRef = useWebEventHandlers();\n  // Store state in ref to prevent unnecessary renders\n  const state = useRef<GestureDetectorState>({\n    firstRender: true,\n    viewRef: null,\n    previousViewTag: -1,\n    forceRebuildReanimatedEvent: false,\n  }).current;\n\n  const preparedGesture = React.useRef<AttachedGestureState>({\n    attachedGestures: [],\n    animatedEventHandler: null,\n    animatedHandlers: null,\n    shouldUseReanimated: shouldUseReanimated,\n    isMounted: false,\n  }).current;\n\n  const updateAttachedGestures = useDetectorUpdater(\n    state,\n    preparedGesture,\n    gesturesToAttach,\n    gestureConfig,\n    webEventHandlersRef\n  );\n\n  const refHandler = useViewRefHandler(state, updateAttachedGestures);\n\n  // Reanimated event should be rebuilt only when gestures are reattached, otherwise\n  // config update will be enough as all necessary items are stored in shared values anyway\n  const needsToRebuildReanimatedEvent =\n    state.firstRender ||\n    state.forceRebuildReanimatedEvent ||\n    needsToReattach(preparedGesture, gesturesToAttach);\n  state.forceRebuildReanimatedEvent = false;\n\n  useAnimatedGesture(preparedGesture, needsToRebuildReanimatedEvent);\n\n  useLayoutEffect(() => {\n    const viewTag = findNodeHandle(state.viewRef) as number;\n    preparedGesture.isMounted = true;\n\n    attachHandlers({\n      preparedGesture,\n      gestureConfig,\n      gesturesToAttach,\n      webEventHandlersRef,\n      viewTag,\n    });\n\n    return () => {\n      preparedGesture.isMounted = false;\n      dropHandlers(preparedGesture);\n    };\n  }, []);\n\n  useEffect(() => {\n    if (state.firstRender) {\n      state.firstRender = false;\n    } else {\n      updateAttachedGestures();\n    }\n  }, [props]);\n\n  useMountReactions(updateAttachedGestures, preparedGesture);\n\n  if (shouldUseReanimated) {\n    return (\n      <AnimatedWrap\n        ref={refHandler}\n        onGestureHandlerEvent={preparedGesture.animatedEventHandler}>\n        {props.children}\n      </AnimatedWrap>\n    );\n  } else {\n    return <Wrap ref={refHandler}>{props.children}</Wrap>;\n  }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}