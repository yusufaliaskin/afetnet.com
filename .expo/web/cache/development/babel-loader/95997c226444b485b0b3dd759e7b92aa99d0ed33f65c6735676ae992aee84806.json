{"ast":null,"code":"\"use strict\";\n\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport { PointerType } from \"../../PointerType\";\nimport { State } from \"../../State\";\nimport PointerTracker from \"./PointerTracker\";\nvar GestureHandlerOrchestrator = function () {\n  function GestureHandlerOrchestrator() {\n    _classCallCheck(this, GestureHandlerOrchestrator);\n    this.gestureHandlers = [];\n    this.awaitingHandlers = [];\n    this.awaitingHandlersTags = new Set();\n    this.handlingChangeSemaphore = 0;\n    this.activationIndex = 0;\n  }\n  return _createClass(GestureHandlerOrchestrator, [{\n    key: \"scheduleFinishedHandlersCleanup\",\n    value: function scheduleFinishedHandlersCleanup() {\n      if (this.handlingChangeSemaphore === 0) {\n        this.cleanupFinishedHandlers();\n      }\n    }\n  }, {\n    key: \"cleanHandler\",\n    value: function cleanHandler(handler) {\n      handler.reset();\n      handler.active = false;\n      handler.awaiting = false;\n      handler.activationIndex = Number.MAX_VALUE;\n    }\n  }, {\n    key: \"removeHandlerFromOrchestrator\",\n    value: function removeHandlerFromOrchestrator(handler) {\n      var indexInGestureHandlers = this.gestureHandlers.indexOf(handler);\n      var indexInAwaitingHandlers = this.awaitingHandlers.indexOf(handler);\n      if (indexInGestureHandlers >= 0) {\n        this.gestureHandlers.splice(indexInGestureHandlers, 1);\n      }\n      if (indexInAwaitingHandlers >= 0) {\n        this.awaitingHandlers.splice(indexInAwaitingHandlers, 1);\n        this.awaitingHandlersTags.delete(handler.handlerTag);\n      }\n    }\n  }, {\n    key: \"cleanupFinishedHandlers\",\n    value: function cleanupFinishedHandlers() {\n      var handlersToRemove = new Set();\n      for (var i = this.gestureHandlers.length - 1; i >= 0; --i) {\n        var handler = this.gestureHandlers[i];\n        if (this.isFinished(handler.state) && !handler.awaiting) {\n          this.cleanHandler(handler);\n          handlersToRemove.add(handler);\n        }\n      }\n      this.gestureHandlers = this.gestureHandlers.filter(function (handler) {\n        return !handlersToRemove.has(handler);\n      });\n    }\n  }, {\n    key: \"hasOtherHandlerToWaitFor\",\n    value: function hasOtherHandlerToWaitFor(handler) {\n      var _this = this;\n      var hasToWaitFor = function hasToWaitFor(otherHandler) {\n        return !_this.isFinished(otherHandler.state) && _this.shouldHandlerWaitForOther(handler, otherHandler);\n      };\n      return this.gestureHandlers.some(hasToWaitFor);\n    }\n  }, {\n    key: \"shouldBeCancelledByFinishedHandler\",\n    value: function shouldBeCancelledByFinishedHandler(handler) {\n      var _this2 = this;\n      var shouldBeCancelled = function shouldBeCancelled(otherHandler) {\n        return _this2.shouldHandlerWaitForOther(handler, otherHandler) && otherHandler.state === State.END;\n      };\n      return this.gestureHandlers.some(shouldBeCancelled);\n    }\n  }, {\n    key: \"tryActivate\",\n    value: function tryActivate(handler) {\n      if (this.shouldBeCancelledByFinishedHandler(handler)) {\n        handler.cancel();\n        return;\n      }\n      if (this.hasOtherHandlerToWaitFor(handler)) {\n        this.addAwaitingHandler(handler);\n        return;\n      }\n      var handlerState = handler.state;\n      if (handlerState === State.CANCELLED || handlerState === State.FAILED) {\n        return;\n      }\n      if (this.shouldActivate(handler)) {\n        this.makeActive(handler);\n        return;\n      }\n      if (handlerState === State.ACTIVE) {\n        handler.fail();\n        return;\n      }\n      if (handlerState === State.BEGAN) {\n        handler.cancel();\n      }\n    }\n  }, {\n    key: \"shouldActivate\",\n    value: function shouldActivate(handler) {\n      var _this3 = this;\n      var shouldBeCancelledBy = function shouldBeCancelledBy(otherHandler) {\n        return _this3.shouldHandlerBeCancelledBy(handler, otherHandler);\n      };\n      return !this.gestureHandlers.some(shouldBeCancelledBy);\n    }\n  }, {\n    key: \"cleanupAwaitingHandlers\",\n    value: function cleanupAwaitingHandlers(handler) {\n      var _this4 = this;\n      var shouldWait = function shouldWait(otherHandler) {\n        return !otherHandler.awaiting && _this4.shouldHandlerWaitForOther(otherHandler, handler);\n      };\n      for (var otherHandler of this.awaitingHandlers) {\n        if (shouldWait(otherHandler)) {\n          this.cleanHandler(otherHandler);\n          this.awaitingHandlersTags.delete(otherHandler.handlerTag);\n        }\n      }\n      this.awaitingHandlers = this.awaitingHandlers.filter(function (otherHandler) {\n        return _this4.awaitingHandlersTags.has(otherHandler.handlerTag);\n      });\n    }\n  }, {\n    key: \"onHandlerStateChange\",\n    value: function onHandlerStateChange(handler, newState, oldState, sendIfDisabled) {\n      if (!handler.enabled && !sendIfDisabled) {\n        return;\n      }\n      this.handlingChangeSemaphore += 1;\n      if (this.isFinished(newState)) {\n        for (var otherHandler of this.awaitingHandlers) {\n          if (!this.shouldHandlerWaitForOther(otherHandler, handler) || !this.awaitingHandlersTags.has(otherHandler.handlerTag)) {\n            continue;\n          }\n          if (newState !== State.END) {\n            this.tryActivate(otherHandler);\n            continue;\n          }\n          otherHandler.cancel();\n          if (otherHandler.state === State.END) {\n            otherHandler.sendEvent(State.CANCELLED, State.BEGAN);\n          }\n          otherHandler.awaiting = false;\n        }\n      }\n      if (newState === State.ACTIVE) {\n        this.tryActivate(handler);\n      } else if (oldState === State.ACTIVE || oldState === State.END) {\n        if (handler.active) {\n          handler.sendEvent(newState, oldState);\n        } else if (oldState === State.ACTIVE && (newState === State.CANCELLED || newState === State.FAILED)) {\n          handler.sendEvent(newState, State.BEGAN);\n        }\n      } else if (oldState !== State.UNDETERMINED || newState !== State.CANCELLED) {\n        handler.sendEvent(newState, oldState);\n      }\n      this.handlingChangeSemaphore -= 1;\n      this.scheduleFinishedHandlersCleanup();\n      if (!this.awaitingHandlers.includes(handler)) {\n        this.cleanupAwaitingHandlers(handler);\n      }\n    }\n  }, {\n    key: \"makeActive\",\n    value: function makeActive(handler) {\n      var currentState = handler.state;\n      handler.active = true;\n      handler.shouldResetProgress = true;\n      handler.activationIndex = this.activationIndex++;\n      for (var i = this.gestureHandlers.length - 1; i >= 0; --i) {\n        if (this.shouldHandlerBeCancelledBy(this.gestureHandlers[i], handler)) {\n          this.gestureHandlers[i].cancel();\n        }\n      }\n      for (var otherHandler of this.awaitingHandlers) {\n        if (this.shouldHandlerBeCancelledBy(otherHandler, handler)) {\n          otherHandler.awaiting = false;\n        }\n      }\n      handler.sendEvent(State.ACTIVE, State.BEGAN);\n      if (currentState !== State.ACTIVE) {\n        handler.sendEvent(State.END, State.ACTIVE);\n        if (currentState !== State.END) {\n          handler.sendEvent(State.UNDETERMINED, State.END);\n        }\n      }\n      if (!handler.awaiting) {\n        return;\n      }\n      handler.awaiting = false;\n      this.awaitingHandlers = this.awaitingHandlers.filter(function (otherHandler) {\n        return otherHandler !== handler;\n      });\n    }\n  }, {\n    key: \"addAwaitingHandler\",\n    value: function addAwaitingHandler(handler) {\n      if (this.awaitingHandlers.includes(handler)) {\n        return;\n      }\n      this.awaitingHandlers.push(handler);\n      this.awaitingHandlersTags.add(handler.handlerTag);\n      handler.awaiting = true;\n      handler.activationIndex = this.activationIndex++;\n    }\n  }, {\n    key: \"recordHandlerIfNotPresent\",\n    value: function recordHandlerIfNotPresent(handler) {\n      if (this.gestureHandlers.includes(handler)) {\n        return;\n      }\n      this.gestureHandlers.push(handler);\n      handler.active = false;\n      handler.awaiting = false;\n      handler.activationIndex = Number.MAX_SAFE_INTEGER;\n    }\n  }, {\n    key: \"shouldHandlerWaitForOther\",\n    value: function shouldHandlerWaitForOther(handler, otherHandler) {\n      return handler !== otherHandler && (handler.shouldWaitForHandlerFailure(otherHandler) || otherHandler.shouldRequireToWaitForFailure(handler));\n    }\n  }, {\n    key: \"canRunSimultaneously\",\n    value: function canRunSimultaneously(gh1, gh2) {\n      return gh1 === gh2 || gh1.shouldRecognizeSimultaneously(gh2) || gh2.shouldRecognizeSimultaneously(gh1);\n    }\n  }, {\n    key: \"shouldHandlerBeCancelledBy\",\n    value: function shouldHandlerBeCancelledBy(handler, otherHandler) {\n      if (this.canRunSimultaneously(handler, otherHandler)) {\n        return false;\n      }\n      if (handler.awaiting || handler.state === State.ACTIVE) {\n        return handler.shouldBeCancelledByOther(otherHandler);\n      }\n      var handlerPointers = handler.getTrackedPointersID();\n      var otherPointers = otherHandler.getTrackedPointersID();\n      if (!PointerTracker.shareCommonPointers(handlerPointers, otherPointers) && handler.delegate.view !== otherHandler.delegate.view) {\n        return this.checkOverlap(handler, otherHandler);\n      }\n      return true;\n    }\n  }, {\n    key: \"checkOverlap\",\n    value: function checkOverlap(handler, otherHandler) {\n      var isPointerWithinBothBounds = function isPointerWithinBothBounds(pointer) {\n        var point = handler.tracker.getLastAbsoluteCoords(pointer);\n        return point && handler.delegate.isPointerInBounds(point) && otherHandler.delegate.isPointerInBounds(point);\n      };\n      return handler.getTrackedPointersID().some(isPointerWithinBothBounds);\n    }\n  }, {\n    key: \"isFinished\",\n    value: function isFinished(state) {\n      return state === State.END || state === State.FAILED || state === State.CANCELLED;\n    }\n  }, {\n    key: \"cancelMouseAndPenGestures\",\n    value: function cancelMouseAndPenGestures(currentHandler) {\n      this.gestureHandlers.forEach(function (handler) {\n        if (handler.pointerType !== PointerType.MOUSE && handler.pointerType !== PointerType.STYLUS) {\n          return;\n        }\n        if (handler !== currentHandler) {\n          handler.cancel();\n        } else {\n          handler.tracker.resetTracker();\n        }\n      });\n    }\n  }], [{\n    key: \"instance\",\n    get: function get() {\n      if (!GestureHandlerOrchestrator._instance) {\n        GestureHandlerOrchestrator._instance = new GestureHandlerOrchestrator();\n      }\n      return GestureHandlerOrchestrator._instance;\n    }\n  }]);\n}();\nexport { GestureHandlerOrchestrator as default };","map":{"version":3,"names":["PointerType","State","PointerTracker","GestureHandlerOrchestrator","_classCallCheck","gestureHandlers","awaitingHandlers","awaitingHandlersTags","Set","handlingChangeSemaphore","activationIndex","_createClass","key","value","scheduleFinishedHandlersCleanup","cleanupFinishedHandlers","cleanHandler","handler","reset","active","awaiting","Number","MAX_VALUE","removeHandlerFromOrchestrator","indexInGestureHandlers","indexOf","indexInAwaitingHandlers","splice","delete","handlerTag","handlersToRemove","i","length","isFinished","state","add","filter","has","hasOtherHandlerToWaitFor","_this","hasToWaitFor","otherHandler","shouldHandlerWaitForOther","some","shouldBeCancelledByFinishedHandler","_this2","shouldBeCancelled","END","tryActivate","cancel","addAwaitingHandler","handlerState","CANCELLED","FAILED","shouldActivate","makeActive","ACTIVE","fail","BEGAN","_this3","shouldBeCancelledBy","shouldHandlerBeCancelledBy","cleanupAwaitingHandlers","_this4","shouldWait","onHandlerStateChange","newState","oldState","sendIfDisabled","enabled","sendEvent","UNDETERMINED","includes","currentState","shouldResetProgress","push","recordHandlerIfNotPresent","MAX_SAFE_INTEGER","shouldWaitForHandlerFailure","shouldRequireToWaitForFailure","canRunSimultaneously","gh1","gh2","shouldRecognizeSimultaneously","shouldBeCancelledByOther","handlerPointers","getTrackedPointersID","otherPointers","shareCommonPointers","delegate","view","checkOverlap","isPointerWithinBothBounds","pointer","point","tracker","getLastAbsoluteCoords","isPointerInBounds","cancelMouseAndPenGestures","currentHandler","forEach","pointerType","MOUSE","STYLUS","resetTracker","get","_instance","default"],"sources":["C:\\Users\\Yusuf Ali Aşkın\\Downloads\\Desktop\\proje_afetnet\\node_modules\\react-native-gesture-handler\\src\\web\\tools\\GestureHandlerOrchestrator.ts"],"sourcesContent":["import { PointerType } from '../../PointerType';\nimport { State } from '../../State';\n\nimport type IGestureHandler from '../handlers/IGestureHandler';\nimport PointerTracker from './PointerTracker';\n\nexport default class GestureHandlerOrchestrator {\n  private static _instance: GestureHandlerOrchestrator;\n\n  private gestureHandlers: IGestureHandler[] = [];\n  private awaitingHandlers: IGestureHandler[] = [];\n  private awaitingHandlersTags: Set<number> = new Set();\n\n  private handlingChangeSemaphore = 0;\n  private activationIndex = 0;\n\n  // Private beacuse of Singleton\n  // eslint-disable-next-line no-useless-constructor, @typescript-eslint/no-empty-function\n  private constructor() {}\n\n  private scheduleFinishedHandlersCleanup(): void {\n    if (this.handlingChangeSemaphore === 0) {\n      this.cleanupFinishedHandlers();\n    }\n  }\n\n  private cleanHandler(handler: IGestureHandler): void {\n    handler.reset();\n    handler.active = false;\n    handler.awaiting = false;\n    handler.activationIndex = Number.MAX_VALUE;\n  }\n\n  public removeHandlerFromOrchestrator(handler: IGestureHandler): void {\n    const indexInGestureHandlers = this.gestureHandlers.indexOf(handler);\n    const indexInAwaitingHandlers = this.awaitingHandlers.indexOf(handler);\n\n    if (indexInGestureHandlers >= 0) {\n      this.gestureHandlers.splice(indexInGestureHandlers, 1);\n    }\n\n    if (indexInAwaitingHandlers >= 0) {\n      this.awaitingHandlers.splice(indexInAwaitingHandlers, 1);\n      this.awaitingHandlersTags.delete(handler.handlerTag);\n    }\n  }\n\n  private cleanupFinishedHandlers(): void {\n    const handlersToRemove = new Set<IGestureHandler>();\n\n    for (let i = this.gestureHandlers.length - 1; i >= 0; --i) {\n      const handler = this.gestureHandlers[i];\n\n      if (this.isFinished(handler.state) && !handler.awaiting) {\n        this.cleanHandler(handler);\n        handlersToRemove.add(handler);\n      }\n    }\n\n    this.gestureHandlers = this.gestureHandlers.filter(\n      (handler) => !handlersToRemove.has(handler)\n    );\n  }\n\n  private hasOtherHandlerToWaitFor(handler: IGestureHandler): boolean {\n    const hasToWaitFor = (otherHandler: IGestureHandler) => {\n      return (\n        !this.isFinished(otherHandler.state) &&\n        this.shouldHandlerWaitForOther(handler, otherHandler)\n      );\n    };\n\n    return this.gestureHandlers.some(hasToWaitFor);\n  }\n\n  private shouldBeCancelledByFinishedHandler(\n    handler: IGestureHandler\n  ): boolean {\n    const shouldBeCancelled = (otherHandler: IGestureHandler) => {\n      return (\n        this.shouldHandlerWaitForOther(handler, otherHandler) &&\n        otherHandler.state === State.END\n      );\n    };\n\n    return this.gestureHandlers.some(shouldBeCancelled);\n  }\n\n  private tryActivate(handler: IGestureHandler): void {\n    if (this.shouldBeCancelledByFinishedHandler(handler)) {\n      handler.cancel();\n      return;\n    }\n\n    if (this.hasOtherHandlerToWaitFor(handler)) {\n      this.addAwaitingHandler(handler);\n      return;\n    }\n\n    const handlerState = handler.state;\n\n    if (handlerState === State.CANCELLED || handlerState === State.FAILED) {\n      return;\n    }\n\n    if (this.shouldActivate(handler)) {\n      this.makeActive(handler);\n      return;\n    }\n\n    if (handlerState === State.ACTIVE) {\n      handler.fail();\n      return;\n    }\n\n    if (handlerState === State.BEGAN) {\n      handler.cancel();\n    }\n  }\n\n  private shouldActivate(handler: IGestureHandler): boolean {\n    const shouldBeCancelledBy = (otherHandler: IGestureHandler) => {\n      return this.shouldHandlerBeCancelledBy(handler, otherHandler);\n    };\n\n    return !this.gestureHandlers.some(shouldBeCancelledBy);\n  }\n\n  private cleanupAwaitingHandlers(handler: IGestureHandler): void {\n    const shouldWait = (otherHandler: IGestureHandler) => {\n      return (\n        !otherHandler.awaiting &&\n        this.shouldHandlerWaitForOther(otherHandler, handler)\n      );\n    };\n\n    for (const otherHandler of this.awaitingHandlers) {\n      if (shouldWait(otherHandler)) {\n        this.cleanHandler(otherHandler);\n        this.awaitingHandlersTags.delete(otherHandler.handlerTag);\n      }\n    }\n\n    this.awaitingHandlers = this.awaitingHandlers.filter((otherHandler) =>\n      this.awaitingHandlersTags.has(otherHandler.handlerTag)\n    );\n  }\n\n  public onHandlerStateChange(\n    handler: IGestureHandler,\n    newState: State,\n    oldState: State,\n    sendIfDisabled?: boolean\n  ): void {\n    if (!handler.enabled && !sendIfDisabled) {\n      return;\n    }\n\n    this.handlingChangeSemaphore += 1;\n\n    if (this.isFinished(newState)) {\n      for (const otherHandler of this.awaitingHandlers) {\n        if (\n          !this.shouldHandlerWaitForOther(otherHandler, handler) ||\n          !this.awaitingHandlersTags.has(otherHandler.handlerTag)\n        ) {\n          continue;\n        }\n\n        if (newState !== State.END) {\n          this.tryActivate(otherHandler);\n          continue;\n        }\n\n        otherHandler.cancel();\n\n        if (otherHandler.state === State.END) {\n          // Handle edge case, where discrete gestures end immediately after activation thus\n          // their state is set to END and when the gesture they are waiting for activates they\n          // should be cancelled, however `cancel` was never sent as gestures were already in the END state.\n          // Send synthetic BEGAN -> CANCELLED to properly handle JS logic\n          otherHandler.sendEvent(State.CANCELLED, State.BEGAN);\n        }\n\n        otherHandler.awaiting = false;\n      }\n    }\n\n    if (newState === State.ACTIVE) {\n      this.tryActivate(handler);\n    } else if (oldState === State.ACTIVE || oldState === State.END) {\n      if (handler.active) {\n        handler.sendEvent(newState, oldState);\n      } else if (\n        oldState === State.ACTIVE &&\n        (newState === State.CANCELLED || newState === State.FAILED)\n      ) {\n        handler.sendEvent(newState, State.BEGAN);\n      }\n    } else if (\n      oldState !== State.UNDETERMINED ||\n      newState !== State.CANCELLED\n    ) {\n      handler.sendEvent(newState, oldState);\n    }\n\n    this.handlingChangeSemaphore -= 1;\n\n    this.scheduleFinishedHandlersCleanup();\n\n    if (!this.awaitingHandlers.includes(handler)) {\n      this.cleanupAwaitingHandlers(handler);\n    }\n  }\n\n  private makeActive(handler: IGestureHandler): void {\n    const currentState = handler.state;\n\n    handler.active = true;\n    handler.shouldResetProgress = true;\n    handler.activationIndex = this.activationIndex++;\n\n    for (let i = this.gestureHandlers.length - 1; i >= 0; --i) {\n      if (this.shouldHandlerBeCancelledBy(this.gestureHandlers[i], handler)) {\n        this.gestureHandlers[i].cancel();\n      }\n    }\n\n    for (const otherHandler of this.awaitingHandlers) {\n      if (this.shouldHandlerBeCancelledBy(otherHandler, handler)) {\n        otherHandler.awaiting = false;\n      }\n    }\n\n    handler.sendEvent(State.ACTIVE, State.BEGAN);\n\n    if (currentState !== State.ACTIVE) {\n      handler.sendEvent(State.END, State.ACTIVE);\n      if (currentState !== State.END) {\n        handler.sendEvent(State.UNDETERMINED, State.END);\n      }\n    }\n\n    if (!handler.awaiting) {\n      return;\n    }\n\n    handler.awaiting = false;\n\n    this.awaitingHandlers = this.awaitingHandlers.filter(\n      (otherHandler) => otherHandler !== handler\n    );\n  }\n\n  private addAwaitingHandler(handler: IGestureHandler): void {\n    if (this.awaitingHandlers.includes(handler)) {\n      return;\n    }\n\n    this.awaitingHandlers.push(handler);\n    this.awaitingHandlersTags.add(handler.handlerTag);\n\n    handler.awaiting = true;\n    handler.activationIndex = this.activationIndex++;\n  }\n\n  public recordHandlerIfNotPresent(handler: IGestureHandler): void {\n    if (this.gestureHandlers.includes(handler)) {\n      return;\n    }\n\n    this.gestureHandlers.push(handler);\n\n    handler.active = false;\n    handler.awaiting = false;\n    handler.activationIndex = Number.MAX_SAFE_INTEGER;\n  }\n\n  private shouldHandlerWaitForOther(\n    handler: IGestureHandler,\n    otherHandler: IGestureHandler\n  ): boolean {\n    return (\n      handler !== otherHandler &&\n      (handler.shouldWaitForHandlerFailure(otherHandler) ||\n        otherHandler.shouldRequireToWaitForFailure(handler))\n    );\n  }\n\n  private canRunSimultaneously(\n    gh1: IGestureHandler,\n    gh2: IGestureHandler\n  ): boolean {\n    return (\n      gh1 === gh2 ||\n      gh1.shouldRecognizeSimultaneously(gh2) ||\n      gh2.shouldRecognizeSimultaneously(gh1)\n    );\n  }\n\n  private shouldHandlerBeCancelledBy(\n    handler: IGestureHandler,\n    otherHandler: IGestureHandler\n  ): boolean {\n    if (this.canRunSimultaneously(handler, otherHandler)) {\n      return false;\n    }\n\n    if (handler.awaiting || handler.state === State.ACTIVE) {\n      return handler.shouldBeCancelledByOther(otherHandler);\n    }\n\n    const handlerPointers: number[] = handler.getTrackedPointersID();\n    const otherPointers: number[] = otherHandler.getTrackedPointersID();\n\n    if (\n      !PointerTracker.shareCommonPointers(handlerPointers, otherPointers) &&\n      handler.delegate.view !== otherHandler.delegate.view\n    ) {\n      return this.checkOverlap(handler, otherHandler);\n    }\n\n    return true;\n  }\n\n  private checkOverlap(\n    handler: IGestureHandler,\n    otherHandler: IGestureHandler\n  ): boolean {\n    // If handlers don't have common pointers, default return value is false.\n    // However, if at least on pointer overlaps with both handlers, we return true\n    // This solves issue in overlapping parents example\n\n    // TODO: Find better way to handle that issue, for example by activation order and handler cancelling\n\n    const isPointerWithinBothBounds = (pointer: number) => {\n      const point = handler.tracker.getLastAbsoluteCoords(pointer);\n\n      return (\n        point &&\n        handler.delegate.isPointerInBounds(point) &&\n        otherHandler.delegate.isPointerInBounds(point)\n      );\n    };\n\n    return handler.getTrackedPointersID().some(isPointerWithinBothBounds);\n  }\n\n  private isFinished(state: State): boolean {\n    return (\n      state === State.END || state === State.FAILED || state === State.CANCELLED\n    );\n  }\n\n  // This function is called when handler receives touchdown event\n  // If handler is using mouse or pen as a pointer and any handler receives touch event,\n  // mouse/pen event dissappears - it doesn't send onPointerCancel nor onPointerUp (and others)\n  // This became a problem because handler was left at active state without any signal to end or fail\n  // To handle this, when new touch event is received, we loop through active handlers and check which type of\n  // pointer they're using. If there are any handler with mouse/pen as a pointer, we cancel them\n  public cancelMouseAndPenGestures(currentHandler: IGestureHandler): void {\n    this.gestureHandlers.forEach((handler: IGestureHandler) => {\n      if (\n        handler.pointerType !== PointerType.MOUSE &&\n        handler.pointerType !== PointerType.STYLUS\n      ) {\n        return;\n      }\n\n      if (handler !== currentHandler) {\n        handler.cancel();\n      } else {\n        // Handler that received touch event should have its pointer tracker reset\n        // This allows handler to smoothly change from mouse/pen to touch\n        // The drawback is, that when we try to use mouse/pen one more time, it doesn't send onPointerDown at the first time\n        // so it is required to click two times to get handler to work\n        //\n        // However, handler will receive manually created onPointerEnter that is triggered in EventManager in onPointerMove method.\n        // There may be possibility to use that fact to make handler respond properly to first mouse click\n        handler.tracker.resetTracker();\n      }\n    });\n  }\n\n  public static get instance(): GestureHandlerOrchestrator {\n    if (!GestureHandlerOrchestrator._instance) {\n      GestureHandlerOrchestrator._instance = new GestureHandlerOrchestrator();\n    }\n\n    return GestureHandlerOrchestrator._instance;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}