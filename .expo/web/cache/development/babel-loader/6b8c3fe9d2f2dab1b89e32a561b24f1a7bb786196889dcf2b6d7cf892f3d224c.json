{"ast":null,"code":"\"use strict\";\n\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport { EventTypes } from \"../interfaces\";\nvar RotationGestureDetector = function () {\n  function RotationGestureDetector(callbacks) {\n    _classCallCheck(this, RotationGestureDetector);\n    this.currentTime = 0;\n    this.previousTime = 0;\n    this.previousAngle = 0;\n    this._rotation = 0;\n    this._anchorX = 0;\n    this._anchorY = 0;\n    this.isInProgress = false;\n    this.keyPointers = [NaN, NaN];\n    this.onRotationBegin = callbacks.onRotationBegin;\n    this.onRotation = callbacks.onRotation;\n    this.onRotationEnd = callbacks.onRotationEnd;\n  }\n  return _createClass(RotationGestureDetector, [{\n    key: \"updateCurrent\",\n    value: function updateCurrent(event, tracker) {\n      this.previousTime = this.currentTime;\n      this.currentTime = event.time;\n      var _this$keyPointers = _slicedToArray(this.keyPointers, 2),\n        firstPointerID = _this$keyPointers[0],\n        secondPointerID = _this$keyPointers[1];\n      var firstPointerCoords = tracker.getLastAbsoluteCoords(firstPointerID);\n      var secondPointerCoords = tracker.getLastAbsoluteCoords(secondPointerID);\n      if (!firstPointerCoords || !secondPointerCoords) {\n        return;\n      }\n      var vectorX = secondPointerCoords.x - firstPointerCoords.x;\n      var vectorY = secondPointerCoords.y - firstPointerCoords.y;\n      this._anchorX = (firstPointerCoords.x + secondPointerCoords.x) / 2;\n      this._anchorY = (firstPointerCoords.y + secondPointerCoords.y) / 2;\n      var angle = -Math.atan2(vectorY, vectorX);\n      this._rotation = Number.isNaN(this.previousAngle) ? 0 : this.previousAngle - angle;\n      this.previousAngle = angle;\n      if (this.rotation > Math.PI) {\n        this._rotation -= Math.PI;\n      } else if (this.rotation < -Math.PI) {\n        this._rotation += Math.PI;\n      }\n      if (this.rotation > Math.PI / 2) {\n        this._rotation -= Math.PI;\n      } else if (this.rotation < -Math.PI / 2) {\n        this._rotation += Math.PI;\n      }\n    }\n  }, {\n    key: \"finish\",\n    value: function finish() {\n      if (!this.isInProgress) {\n        return;\n      }\n      this.isInProgress = false;\n      this.keyPointers = [NaN, NaN];\n      this.onRotationEnd(this);\n    }\n  }, {\n    key: \"setKeyPointers\",\n    value: function setKeyPointers(tracker) {\n      if (this.keyPointers[0] && this.keyPointers[1]) {\n        return;\n      }\n      var pointerIDs = tracker.trackedPointers.keys();\n      this.keyPointers[0] = pointerIDs.next().value;\n      this.keyPointers[1] = pointerIDs.next().value;\n    }\n  }, {\n    key: \"onTouchEvent\",\n    value: function onTouchEvent(event, tracker) {\n      switch (event.eventType) {\n        case EventTypes.DOWN:\n          this.isInProgress = false;\n          break;\n        case EventTypes.ADDITIONAL_POINTER_DOWN:\n          if (this.isInProgress) {\n            break;\n          }\n          this.isInProgress = true;\n          this.previousTime = event.time;\n          this.previousAngle = NaN;\n          this.setKeyPointers(tracker);\n          this.updateCurrent(event, tracker);\n          this.onRotationBegin(this);\n          break;\n        case EventTypes.MOVE:\n          if (!this.isInProgress) {\n            break;\n          }\n          this.updateCurrent(event, tracker);\n          this.onRotation(this);\n          break;\n        case EventTypes.ADDITIONAL_POINTER_UP:\n          if (!this.isInProgress) {\n            break;\n          }\n          if (this.keyPointers.indexOf(event.pointerId) >= 0) {\n            this.finish();\n          }\n          break;\n        case EventTypes.UP:\n          if (this.isInProgress) {\n            this.finish();\n          }\n          break;\n      }\n      return true;\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this.keyPointers = [NaN, NaN];\n      this.isInProgress = false;\n    }\n  }, {\n    key: \"anchorX\",\n    get: function get() {\n      return this._anchorX;\n    }\n  }, {\n    key: \"anchorY\",\n    get: function get() {\n      return this._anchorY;\n    }\n  }, {\n    key: \"rotation\",\n    get: function get() {\n      return this._rotation;\n    }\n  }, {\n    key: \"timeDelta\",\n    get: function get() {\n      return this.currentTime + this.previousTime;\n    }\n  }]);\n}();\nexport { RotationGestureDetector as default };","map":{"version":3,"names":["EventTypes","RotationGestureDetector","callbacks","_classCallCheck","currentTime","previousTime","previousAngle","_rotation","_anchorX","_anchorY","isInProgress","keyPointers","NaN","onRotationBegin","onRotation","onRotationEnd","_createClass","key","value","updateCurrent","event","tracker","time","_this$keyPointers","_slicedToArray","firstPointerID","secondPointerID","firstPointerCoords","getLastAbsoluteCoords","secondPointerCoords","vectorX","x","vectorY","y","angle","Math","atan2","Number","isNaN","rotation","PI","finish","setKeyPointers","pointerIDs","trackedPointers","keys","next","onTouchEvent","eventType","DOWN","ADDITIONAL_POINTER_DOWN","MOVE","ADDITIONAL_POINTER_UP","indexOf","pointerId","UP","reset","get","default"],"sources":["C:\\Users\\Yusuf Ali Aşkın\\Downloads\\Desktop\\proje_afetnet\\node_modules\\react-native-gesture-handler\\src\\web\\detectors\\RotationGestureDetector.ts"],"sourcesContent":["import { AdaptedEvent, EventTypes } from '../interfaces';\nimport PointerTracker from '../tools/PointerTracker';\n\nexport interface RotationGestureListener {\n  onRotationBegin: (detector: RotationGestureDetector) => boolean;\n  onRotation: (detector: RotationGestureDetector) => boolean;\n  onRotationEnd: (detector: RotationGestureDetector) => void;\n}\n\nexport default class RotationGestureDetector\n  implements RotationGestureListener\n{\n  onRotationBegin: (detector: RotationGestureDetector) => boolean;\n  onRotation: (detector: RotationGestureDetector) => boolean;\n  onRotationEnd: (detector: RotationGestureDetector) => void;\n\n  private currentTime = 0;\n  private previousTime = 0;\n\n  private previousAngle = 0;\n  private _rotation = 0;\n\n  private _anchorX = 0;\n  private _anchorY = 0;\n\n  private isInProgress = false;\n\n  private keyPointers: number[] = [NaN, NaN];\n\n  constructor(callbacks: RotationGestureListener) {\n    this.onRotationBegin = callbacks.onRotationBegin;\n    this.onRotation = callbacks.onRotation;\n    this.onRotationEnd = callbacks.onRotationEnd;\n  }\n\n  private updateCurrent(event: AdaptedEvent, tracker: PointerTracker): void {\n    this.previousTime = this.currentTime;\n    this.currentTime = event.time;\n\n    const [firstPointerID, secondPointerID] = this.keyPointers;\n\n    const firstPointerCoords = tracker.getLastAbsoluteCoords(firstPointerID);\n    const secondPointerCoords = tracker.getLastAbsoluteCoords(secondPointerID);\n\n    if (!firstPointerCoords || !secondPointerCoords) {\n      return;\n    }\n\n    const vectorX: number = secondPointerCoords.x - firstPointerCoords.x;\n    const vectorY: number = secondPointerCoords.y - firstPointerCoords.y;\n\n    this._anchorX = (firstPointerCoords.x + secondPointerCoords.x) / 2;\n    this._anchorY = (firstPointerCoords.y + secondPointerCoords.y) / 2;\n\n    // Angle diff should be positive when rotating in clockwise direction\n    const angle: number = -Math.atan2(vectorY, vectorX);\n\n    this._rotation = Number.isNaN(this.previousAngle)\n      ? 0\n      : this.previousAngle - angle;\n\n    this.previousAngle = angle;\n\n    if (this.rotation > Math.PI) {\n      this._rotation -= Math.PI;\n    } else if (this.rotation < -Math.PI) {\n      this._rotation += Math.PI;\n    }\n\n    if (this.rotation > Math.PI / 2) {\n      this._rotation -= Math.PI;\n    } else if (this.rotation < -Math.PI / 2) {\n      this._rotation += Math.PI;\n    }\n  }\n\n  private finish(): void {\n    if (!this.isInProgress) {\n      return;\n    }\n\n    this.isInProgress = false;\n    this.keyPointers = [NaN, NaN];\n    this.onRotationEnd(this);\n  }\n\n  private setKeyPointers(tracker: PointerTracker): void {\n    if (this.keyPointers[0] && this.keyPointers[1]) {\n      return;\n    }\n\n    const pointerIDs: IterableIterator<number> = tracker.trackedPointers.keys();\n\n    this.keyPointers[0] = pointerIDs.next().value as number;\n    this.keyPointers[1] = pointerIDs.next().value as number;\n  }\n\n  public onTouchEvent(event: AdaptedEvent, tracker: PointerTracker): boolean {\n    switch (event.eventType) {\n      case EventTypes.DOWN:\n        this.isInProgress = false;\n        break;\n\n      case EventTypes.ADDITIONAL_POINTER_DOWN:\n        if (this.isInProgress) {\n          break;\n        }\n        this.isInProgress = true;\n\n        this.previousTime = event.time;\n        this.previousAngle = NaN;\n\n        this.setKeyPointers(tracker);\n\n        this.updateCurrent(event, tracker);\n        this.onRotationBegin(this);\n        break;\n\n      case EventTypes.MOVE:\n        if (!this.isInProgress) {\n          break;\n        }\n\n        this.updateCurrent(event, tracker);\n        this.onRotation(this);\n\n        break;\n\n      case EventTypes.ADDITIONAL_POINTER_UP:\n        if (!this.isInProgress) {\n          break;\n        }\n\n        if (this.keyPointers.indexOf(event.pointerId) >= 0) {\n          this.finish();\n        }\n\n        break;\n\n      case EventTypes.UP:\n        if (this.isInProgress) {\n          this.finish();\n        }\n        break;\n    }\n\n    return true;\n  }\n\n  public reset(): void {\n    this.keyPointers = [NaN, NaN];\n    this.isInProgress = false;\n  }\n\n  public get anchorX() {\n    return this._anchorX;\n  }\n\n  public get anchorY() {\n    return this._anchorY;\n  }\n\n  public get rotation() {\n    return this._rotation;\n  }\n\n  public get timeDelta() {\n    return this.currentTime + this.previousTime;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}